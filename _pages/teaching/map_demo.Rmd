---
output:
  github_document
---

<!---Note this will remove itself:-->

<!---
permalink: /teaching/map_demo
title: A quick demo of the MAP R package
toc: true
--->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The Malaria Atlas Project (MAP) have made many of their great products available through an R package, `malariaAtlas`. This means that if you're writing up some research that uses one of their products, your code can call up MAP products directly without problems for data access and reproducibility.

I don't work for MAP but I've used lots of their stuff in my own research and I've been asked on a number of occasions by colleagues for help to use the MAP package - specifically to get at MAP's estimates of *Plasmodium falciparum* parasite rate in 2-10 year olds (PfPR), described [here](https://doi.org/10.1016/S0140-6736(19)31097-9).

Here's a link to the official MAP package vignette:

https://github.com/malaria-atlas-project/malariaAtlas/blob/master/vignettes/overview.Rmd

This has lots of detail related to all of the different features of the package. I'm not trying to recreate that here!

But, if you're specifically trying to get at PfPR (or another MAP surface) for a couple of points/countries, here's a short demonstration to get you started.

Download this demo as an `.Rmd` <here><https://lu-harr.github.io/_pages/teaching/map_demo.Rmd>

## Bring in packages

```{r pkgs, message=FALSE}
library(malariaAtlas)
library(sf)
library(terra)
library(tidyverse)
library(viridisLite)
```

## Bring in (country) shapes and check available rasters

Rasters == gridded datasets/model predictions provided by MAP.

In this example, I'm looking at India. I specify the admin level (zero == national) - this could be smaller, or I could ask the MAP package for data for multiple countries at a time.

```{r map_interact}
ind_shp <- getShp(ISO = "IND", admin_level = "admin0") %>%
  suppressMessages()

ind_shp %>%
  st_simplify(dTolerance = 0.1) %>%
  st_geometry() %>%
  plot() %>%
  suppressWarnings()
```

If you wanted to grab data for a whole continent, say Africa, you could grab your shape from elsewhere:

```{r, eval=FALSE}
library(rnaturalearth)
library(rnaturalearthdata)
world <- ne_countries(scale="medium", returnclass = "sf")

afr <- world %>%
  filter(continent == "Africa") %>%
  vect() %>%
  crop(ext(-21, 63, -35, 37))

afr %>%
  st_as_sf() %>%
  st_geometry() %>%
  plot()
```

Here's a snippet to check which rasters MAP has available to us:

```{r pfpr_data}
# all_dat is a list of available rasters
all_dat = malariaAtlas::listRaster(printed = FALSE)

# let's see if we can find Pf parasite rate .....
all_dat$dataset_id[grep("PfPR", all_dat$dataset_id)]
# I had thought that there was PfPR up to 2022?
all_dat[all_dat$dataset_id == "Explorer__2020_Global_PfPR",]
# years available 2000-2019

# in fact, I was grepping the wrong thing:
all_dat$dataset_id[grep("Pf_Parasite_Rate", all_dat$dataset_id)]
all_dat[all_dat$dataset_id == "Malaria__202406_Global_Pf_Parasite_Rate",]

# for example, these might be years we're interested in:
pfpr_years <- 2015:2022
```

## Download rasters and extract values

Once we've picked a raster to download, here's the code to do the download:

```{r map_download, eval = FALSE}
pfpr <- malariaAtlas::getRaster("Malaria__202406_Global_Pf_Parasite_Rate",
                                shp = ind_shp,
                                year = pfpr_years) %>%
  suppressMessages() # which gives me a SpatRasterCollection

pfpr <- as.list(pfpr) %>%
          rast() %>%
          suppressMessages()

writeRaster(pfpr, "pfpr_rasters_ind.tif")
```

```{r, echo = FALSE}
pfpr <- rast("pfpr_rasters_ind.tif")
```

If you've read this far, you've probably got some specific points in space/time that you would like to extract MAP raster values for. For our worked example, let's make up some locations (in space and time) in India:

```{r}
pts <- terra::spatSample(pfpr[[1]], size = 100, method = "random", xy = TRUE)
# drop points that don't have values in our raster (e.g., ocean/neighbouring country)
pts <- pts[!is.na(pts[,3]), 1:2]
# randomly assign some years:
pts$year <- sample(pfpr_years, nrow(pts), replace = TRUE)

# and have a look:
head(pts)

ind_shp %>%
  st_simplify(dTolerance = 0.1) %>%
  st_geometry() %>%
  plot(main="We've sampled some points in India") %>%
  suppressWarnings()
points(pts$x, pts$y)
```

and here's the code to extract values from the rasters at locations in the dataset:

```{r}
# remove some extra rasters we don't need for this:
pfpr <- pfpr[[-c(which(names(pfpr) == "Mask: Sparsely Populated"))]]

library(stringr)
names(pfpr) <- ifelse(grepl("Proportion of Children 2", names(pfpr)),
                      paste0(str_sub(names(pfpr), -4), "_median"),
                      ifelse(str_sub(names(pfpr), -1) == "4",
                        paste0(str_sub(names(pfpr), 41, 44), "_upper"),
                        paste0(str_sub(names(pfpr), 41, 44), "_lower")))

extract_pfpr <- function(pfpr, pts, yr){
  # a function to extract pfpr for a specific year, `yr`
  
  idx <- which(pts$year == yr)
  
  # can't grep on the yr by itself which is a pain - have renamed lyrs above
  pfpr <- pfpr[[grep(yr, names(pfpr))]]
  out <- terra::extract(pfpr, pts[idx, c("x", "y")], ID=FALSE)
  
  # I *think* the second and third surfaces are lower and upper bounds ..
  names(out) <- c("median", "lower", "upper")
  cbind(out, pts[idx,])
}

df <- do.call(rbind, lapply(pfpr_years, function(yr){extract_pfpr(pfpr, pts, yr)}))

write.csv(pts, "pts_with_pfpr.csv", row.names = FALSE)
```

## Have a look at what we've extracted

```{r}

hist(df$median, main = "PfPR extracted")

ind_shp %>%
  st_simplify(dTolerance = 0.1) %>%
  st_geometry() %>%
  plot(main = "We've associated our points with PfPR values") %>%
  suppressWarnings()
points(df$x, df$y, col = viridis(10)[cut(log10(df$median), breaks=10)], pch=16)
# i should really put a scale here but that's all for now!
```




